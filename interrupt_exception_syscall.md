中断处理机制

硬件
    设置中断标记（cpu初始化）
    1. cpu根据标记产生中断, 中断号发给os

软件
    保存当前处理状态
    根据中断号找到地址，中断服务程序处理
    清除中断标记
    恢复之前保存的处理状态


异常处理机制

异常： 异常编号
1. 保存现场
2. 异常处理（杀死产生了异常的程序，重新执行异常指令）
3. 恢复现场


系统调用（程序需要os帮助）
如： print 会触发系统调用 write
程序访问主要是通过高层次的API接口而不是直接进行系用调用（如：win32 api),定义了到底os能提供哪些系统调用

用户态：特权级低
内核态：os可执行任意一条指令，可执行特权指令
系统调用会进行用户态到内核态的转换

系统调用和函数调用的区别：系统调用涉及到堆栈的切换, cost高，但是也更安全




所谓的控制权，就是看CPU跑的是谁的代码，如果跑的是应用程序的代码，应用程序就决定CPU做什么，如果跑的是操作系统的代码，操作系统就可以选择，下一步把CPU交给谁。

第一招，叫系统调用。大概意思就是，应用程序，你用吧，我让你用，但你不可能只用CPU吧，如果你需要内存，文件，网络等资源，你就得调用我。如果你调用了我，CPU就跑了我的代码，我就可以把控制权拿下。可这一招，有漏洞，有的程序，对CPU的需求特别大，对其他资源的需求少，所以它就可能长时间占用CPU。

第二招，时钟中断。就像大圣打妖怪，打不过，就找菩萨，找老君。操作系统也一样，权利再大，它本身也是代码，遇到解决不了的问题，就求救硬件。时钟中断就是一个例子。你的主板里，会有一个时钟，滴滴答答的走着，每隔一段时间，它就会给CPU发信号。CPU收到信号，就会执行预先设定好的操作系统的代码，一旦这些代码被执行了，操作系统就有控制权了。

citation: https://hui-wang.info/2018/03/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%B9CPU%E7%9A%84%E6%8E%A7%E5%88%B6%E6%9D%83/